// Appwrite implementation of the database helper
const getAppwrite = () => window.appwrite || {};

window.dbInit = async () => {
    if (window.location.protocol === 'file:') {
        const msg = "âš ï¸ Ù…ØªØµÙØ­Ùƒ ÙŠÙ…Ù†Ø¹ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù€ Appwrite Ø¹Ù†Ø¯ ÙØªØ­ Ø§Ù„Ù…Ù„Ù Ù…Ø¨Ø§Ø´Ø±Ø© (file://).\n\nÙŠØ±Ø¬Ù‰ ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Live Server Ø£Ùˆ Ø±ÙØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª Ø¹Ù„Ù‰ Ø§Ø³ØªØ¶Ø§ÙØ©ØŒ Ø£Ùˆ Ø¥Ø¶Ø§ÙØ© 'null' ÙƒÙ€ Platform ÙÙŠ Ù„ÙˆØ­Ø© Appwrite.";
        console.warn(msg);
        // We only alert once per session
        if (!sessionStorage.getItem('cors_warned')) {
            alert(msg);
            sessionStorage.setItem('cors_warned', 'true');
        }
    }
    return true;
};

// --- MATERIALS FUNCTIONS ---
window.dbAdd = async (item) => {
    const { databases, storage, DB_ID, COLLECTIONS, BUCKET_ID, ID } = getAppwrite();
    console.log("ðŸ’¾ dbAdd function (Appwrite) triggered with item:", item);
    try {
        if (!databases) throw new Error("Appwrite not initialized");
        if (item.isBlob && item.url instanceof File) {
            console.log("ðŸ“¤ Detected file upload. Ref:", item.id);
            const file = item.url;

            console.log(`â³ Uploading to Appwrite storage (Bucket: ${BUCKET_ID})...`);
            // Capture the response to get the actual ID generated by the server
            const response = await storage.createFile(BUCKET_ID, ID.unique(), file);
            const actualFileId = response.$id;

            console.log(`âœ… Upload complete. ID: ${actualFileId}`);

            // Use the actual ID for URL generation
            const downloadURL = storage.getFileView(BUCKET_ID, actualFileId).href;

            item.url = downloadURL;
            item.isBlob = false;
            item.storagePath = actualFileId;
        }

        const docId = String(item.id);
        console.log("ðŸ“ Attempting to save to Appwrite Database. Collection:", COLLECTIONS.MATERIALS, "ID:", docId);

        // Ensure dataToSave is a clean object for Appwrite
        const dataToSave = { ...item };
        // If url is still a File (meaning upload failed or was skipped), remove it or convert it
        if (dataToSave.url instanceof File) {
            delete dataToSave.url;
        }

        await databases.createDocument(DB_ID, COLLECTIONS.MATERIALS, docId, dataToSave);

        console.log("âœ… Appwrite save successful!");
        return item;
    } catch (e) {
        console.error("âŒ Appwrite Add Error:", e);
        let errorMsg = e.message || "Ø®Ø·Ø£ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ";
        const errorCode = e.code || "";

        if (errorCode === 401 || errorCode === 403) {
            errorMsg = "Ù…Ø´ÙƒÙ„Ø© ÙÙŠ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª (Permissions). ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù€ Permissions ÙÙŠ Appwrite Ù„Ù€ Any (create/read).";
        } else if (errorMsg.includes("Attribute not found")) {
            errorMsg = "Ø§Ù„Ù…ØªØµÙØ­ Ù„Ù… ÙŠØ¬Ø¯ Ø¨Ø¹Ø¶ Ø§Ù„Ø­Ù‚ÙˆÙ„ ÙÙŠ Appwrite. ÙŠØ±Ø¬Ù‰ ØªØ´ØºÙŠÙ„ Ù…Ù„Ù fix-appwrite.html Ø£ÙˆÙ„Ø§Ù‹.";
        } else if (errorCode === 400) {
            if (errorMsg.includes("limit allowed for your plan")) {
                errorMsg = "âš ï¸ Ø­Ø¬Ù… Ø§Ù„Ù…Ù„Ù ÙƒØ¨ÙŠØ± Ø¬Ø¯Ø§Ù‹ Ø¨Ø§Ù„Ù†Ø³Ø¨Ø© Ù„Ù„Ø®Ø·Ø© Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠØ© ÙÙŠ Appwrite. ÙŠØ±Ø¬Ù‰ Ø±ÙØ¹ Ù…Ù„Ù Ø£ØµØºØ± Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø±Ø§Ø¨Ø· Ø®Ø§Ø±Ø¬ÙŠ (Ù…Ø«Ù„ Google Drive/YouTube).";
            } else {
                errorMsg = "Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ØµØ§Ù„Ø­Ø© (Schema Mismatch). ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø­Ù‚ÙˆÙ„ (Integer/String). " + errorMsg;
            }
        }

        alert("Ø®Ø·Ø£ (Code " + errorCode + "): " + errorMsg);
        throw e;
    }
};

window.dbGetAll = async () => {
    const { databases, DB_ID, COLLECTIONS } = getAppwrite();
    try {
        if (!databases) throw new Error("Appwrite not initialized");
        const response = await databases.listDocuments(DB_ID, COLLECTIONS.MATERIALS);
        return response.documents;
    } catch (e) {
        console.error("Appwrite dbGetAll Error:", e);
        return [];
    }
};

window.dbDelete = async (id) => {
    const { databases, storage, DB_ID, COLLECTIONS, BUCKET_ID } = getAppwrite();
    const docId = String(id);
    try {
        if (!databases) throw new Error("Appwrite not initialized");
        const doc = await databases.getDocument(DB_ID, COLLECTIONS.MATERIALS, docId);

        // Only try to delete from storage if storagePath is valid (not "unique()" or empty)
        if (doc.storagePath && doc.storagePath !== "unique()" && !doc.storagePath.includes("unique()")) {
            try {
                await storage.deleteFile(BUCKET_ID, doc.storagePath);
                console.log("âœ… File deleted from storage:", doc.storagePath);
            } catch (storageErr) {
                console.warn("âš ï¸ Could not delete file from storage (might not exist):", storageErr);
                // Continue with database deletion even if storage deletion fails
            }
        } else {
            console.log("â­ï¸ Skipping storage deletion (invalid or missing storagePath)");
        }

        await databases.deleteDocument(DB_ID, COLLECTIONS.MATERIALS, docId);
        console.log("âœ… Document deleted from database");
    } catch (e) {
        console.error("âŒ Delete error:", e);
        alert("Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø­Ø°Ù: " + (e.message || "Ø®Ø·Ø£ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ"));
        throw e;
    }
};

// --- USERS FUNCTIONS ---
window.dbUserLogin = async (username, password) => {
    const { databases, DB_ID, COLLECTIONS, Query } = getAppwrite();
    try {
        if (!databases) throw new Error("Appwrite not initialized");
        const response = await databases.listDocuments(DB_ID, COLLECTIONS.USERS, [
            Query.equal("username", username)
        ]);

        if (response.total === 0) return null;

        const user = response.documents[0];
        if (user.password === password) {
            // Map Appwrite attributes to match expectations if needed
            return {
                ...user,
                id: user.id || parseInt(user.$id) || user.$id, // Fallback for ID handling
                role: user.role || 'student'
            };
        }
        return null;
    } catch (e) {
        console.error("Login Error:", e);
        return null;
    }
};

window.dbUserGetAll = async () => {
    const { databases, DB_ID, COLLECTIONS } = getAppwrite();
    try {
        if (!databases) throw new Error("Appwrite not initialized");
        const response = await databases.listDocuments(DB_ID, COLLECTIONS.USERS, [
            Query.limit(100)
        ]);
        return response.documents;
    } catch (e) {
        console.error("User GetAll Error:", e);
        return [];
    }
};

window.dbUserAdd = async (user) => {
    const { databases, DB_ID, COLLECTIONS, Query } = getAppwrite();
    try {
        if (!databases) throw new Error("Appwrite not initialized");
        const check = await databases.listDocuments(DB_ID, COLLECTIONS.USERS, [
            Query.equal("username", user.username)
        ]);
        if (check.total > 0) {
            throw new Error("Username already exists");
        }

        const docId = String(user.id);
        let email = user.email || "";

        // Robust Auto-fix: Ensure email is a valid format and only ASCII for Appwrite
        const isEmailValid = (em) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(em) && /^[\x00-\x7F]*$/.test(em);

        if (!isEmailValid(email)) {
            const safeUsername = (user.username || "student").replace(/[^\x00-\x7F]/g, "") || user.id || "user" + Math.floor(Math.random() * 1000);
            email = `${safeUsername}@batucenter.com`;
            console.log(`ðŸ§¹ Auto-formatting invalid email to: ${email}`);
        }

        const data = {
            id: user.id,
            firstName: user.firstName || "",
            lastName: user.lastName || "",
            email: email,
            username: user.username,
            password: user.password,
            passwordHash: user.password, // Schema requires this
            createdAt: user.createdAt || new Date().toISOString(),
            creationDate: user.createdAt || new Date().toISOString(), // Schema requires this
            isSuspended: user.isSuspended || false,
            isActive: true, // Schema requires this
            deviceId: user.deviceId || null,
            avatar: user.avatar || null,
            role: user.role || 'student'
        };
        await databases.createDocument(DB_ID, COLLECTIONS.USERS, docId, data);
        return user;
    } catch (e) {
        console.error("User Add Error:", e);
        let errorMsg = e.message || "Ø®Ø·Ø£ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ";
        const errorCode = e.code || "";
        if (errorCode === 409) errorMsg = "Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„!";
        else if (errorCode === 401 || errorCode === 403) errorMsg = "Ù…Ø´ÙƒÙ„Ø© ÙÙŠ Ø§Ù„Ø£Ø°ÙˆÙ†Ø§Øª (Permissions) Ù„ÙƒÙˆÙ„ÙŠÙƒØ´Ù† Users.";

        alert("Ø®Ø·Ø£ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³ØªØ®Ø¯Ù… (Code " + errorCode + "): " + errorMsg);
        throw e;
    }
};

window.dbUserUpdate = async (user) => {
    const { databases, DB_ID, COLLECTIONS } = getAppwrite();
    try {
        if (!databases) throw new Error("Appwrite not initialized");
        const docId = String(user.id || user.$id);
        // Exclude Appwrite system keys from update payload
        const { $id, $createdAt, $updatedAt, $permissions, $databaseId, $collectionId, docId: dId, ...data } = user;

        await databases.updateDocument(DB_ID, COLLECTIONS.USERS, docId, data);
        return user;
    } catch (e) {
        console.error("User Update Error:", e);
        alert("Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ø§Ù„Ø¨: " + (e.message || "Ø®Ø·Ø£ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ") + " (Code: " + (e.code || "None") + ")");
        throw e;
    }
};

window.dbUserDelete = async (id) => {
    const { databases, DB_ID, COLLECTIONS } = getAppwrite();
    const docId = String(id);
    try {
        if (!databases) throw new Error("Appwrite not initialized");
        await databases.deleteDocument(DB_ID, COLLECTIONS.USERS, docId);
    } catch (e) {
        console.error("User Delete Error:", e);
    }
};

// --- LOGS FUNCTIONS ---
window.dbLogAdd = async (logData) => {
    const { databases, storage, DB_ID, COLLECTIONS, BUCKET_ID, ID } = getAppwrite();
    console.log("ðŸ’¾ Attempting to add security log:", logData);
    try {
        if (!databases) throw new Error("Appwrite not initialized");

        let screenshotUrl = logData.screenshotUrl || null;

        // If screenshot is present, handle upload
        if (logData.screenshot) {
            try {
                console.log("ðŸ“¤ Uploading violation screenshot...");
                let fileToUpload;

                if (logData.screenshot instanceof File) {
                    fileToUpload = logData.screenshot;
                } else if (logData.screenshot instanceof Blob) {
                    fileToUpload = new File([logData.screenshot], `violation_${Date.now()}.png`, { type: 'image/png' });
                } else if (typeof logData.screenshot === 'string' && logData.screenshot.startsWith('data:')) {
                    // Convert Base64 (DataURL) to Blob then File
                    const res = await fetch(logData.screenshot);
                    const blob = await res.blob();
                    fileToUpload = new File([blob], `violation_${Date.now()}.png`, { type: 'image/png' });
                }

                if (fileToUpload) {
                    const uploadPromise = storage.createFile(BUCKET_ID, ID.unique(), fileToUpload);
                    const response = await uploadPromise;
                    screenshotUrl = storage.getFileView(BUCKET_ID, response.$id).href;
                    console.log("âœ… Screenshot uploaded: ", screenshotUrl);
                } else {
                    console.warn("âš ï¸ Screenshot data format not recognized (not File/Blob/DataURL).");
                }
            } catch (err) {
                console.warn("âš ï¸ Screenshot upload failed (but continuing with log):", err);
            }
        }

        console.log("ðŸš€ dbLogAdd: Start mapping data...");
        // Map to standard schema
        const finalLog = {
            userId: String(logData.userId || logData.username || 'Unknown Student').substring(0, 100),
            action: String(logData.action || logData.type || 'Violation').substring(0, 255),
            timestamp: new Date().toISOString(),
            details: String(screenshotUrl || logData.details || window.location.href || '').substring(0, 1000),
            ip: String(logData.ip || '').substring(0, 50)
        };

        console.log("ðŸ“ dbLogAdd: Sending to Appwrite:", finalLog);
        const res = await databases.createDocument(DB_ID, COLLECTIONS.LOGS, ID.unique(), finalLog);
        console.log("âœ… dbLogAdd: Success! ID:", res.$id);
        return res;
    } catch (e) {
        console.error("âŒ dbLogAdd Error:", e);

        const role = localStorage.getItem('user_role');
        if (role === 'admin' || window.location.href.includes('admin.html')) {
            alert("âš ï¸ Ø®Ø·Ø£ ÙÙŠ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…Ø®Ø§Ù„ÙØ©: " + (e.message || "Ø®Ø·Ø£ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ") +
                "\nØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ Attributes ÙˆØ§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª.");
        }
        throw e;
    }
};

window.dbLogGetAll = async () => {
    const { databases, DB_ID, COLLECTIONS, Query } = getAppwrite();
    try {
        if (!databases) throw new Error("Appwrite not initialized");

        // Strategy Update: Always fetch unsorted first to guarantee data (bypassing Index issues)
        // Then sort in client-side memory. This is safer for small/medium apps.
        const response = await databases.listDocuments(DB_ID, COLLECTIONS.LOGS, [
            Query.limit(100)
        ]);

        // Manual sort: Newest first
        return response.documents.sort((a, b) => {
            const tA = new Date(a.timestamp || a.$createdAt).getTime();
            const tB = new Date(b.timestamp || b.$createdAt).getTime();
            return tB - tA;
        });

    } catch (e) {
        console.error("Log GetAll Error:", e);
        throw e; // Propagate error to caller (Admin UI) so it shows "Failed" instead of "Empty"
    }
};

window.dbLogClearAll = async () => {
    const { databases, DB_ID, COLLECTIONS, Query } = getAppwrite();
    try {
        if (!databases) throw new Error("Appwrite not initialized");

        // Fetch logs to clear
        const response = await databases.listDocuments(DB_ID, COLLECTIONS.LOGS, [
            Query.limit(100)
        ]);

        console.log(`ðŸ§¹ Clearing ${response.documents.length} logs...`);
        const deletePromises = response.documents.map(doc =>
            databases.deleteDocument(DB_ID, COLLECTIONS.LOGS, doc.$id)
        );

        await Promise.all(deletePromises);

        // If there were 100, there might be more. Recursively call if needed or just tell user to refresh.
        // For simplicity, we clear 100 at a time.
        return true;
    } catch (e) {
        console.error("Log Clear Error:", e);
        throw e;
    }
};
